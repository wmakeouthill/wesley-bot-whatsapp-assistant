name: Deploy Oracle VPS Seguro
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Instalar OCI CLI (Oracle Cloud Infrastructure CLI)
        run: |
          python -m pip install --upgrade pip
          pip install oci-cli

      - name: Configurar Credenciais Oracle (OCI)
        run: |
          mkdir -p ~/.oci
          cat << 'EOF' > ~/.oci/config
          [DEFAULT]
          user=${{ secrets.OCI_USER_OCID }}
          fingerprint=${{ secrets.OCI_FINGERPRINT }}
          tenancy=${{ secrets.OCI_TENANCY_OCID }}
          region=${{ secrets.OCI_REGION }}
          key_file=/home/runner/.oci/oci_api_key.pem
          EOF

          # Modo seguro de injetar chaves multilinhas no Linux sem quebrar
          cat << 'EOF' > ~/.oci/oci_api_key.pem
          ${{ secrets.OCI_API_KEY }}
          EOF

          chmod 600 ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/config

      - name: Descobrir IP DinÃ¢mico do GitHub Actions
        id: ip
        run: |
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "ip=$RUNNER_IP" >> $GITHUB_OUTPUT
          echo "IP do Github Actions descoberto: $RUNNER_IP"

      - name: (Security) ABRIR Porta 22 SSH Apenas para o GitHub Actions
        run: |
          set -e
          RUNNER_IP=${{ steps.ip.outputs.ip }}
          SL_OCID="${{ secrets.OCI_SECURITY_LIST_OCID }}"

          if [ -z "$SL_OCID" ]; then
            echo "âŒ ERRO: A variÃ¡vel OCI_SECURITY_LIST_OCID nÃ£o foi encontrada no Github Secrets ou estÃ¡ vazia!"
            exit 2
          fi

          echo "ðŸ”„ Buscando regras do Firewall na Oracle..."
          # Testa autenticaÃ§Ã£o e salva em arquivo para debug
          if ! oci network security-list get --security-list-id "$SL_OCID" --auth api_key --query 'data."ingress-security-rules"' --output json > rules.json; then
             echo "âŒ ERRO: A Oracle rejeitou a conexÃ£o. OCI_API_KEY ou os IDs de Tenancy/User podem estar com espaÃ§os em branco!"
             exit 2
          fi

          echo "âœ… ConexÃ£o com a Oracle bem sucedida! Injetando IP $RUNNER_IP..."
          RULES=$(cat rules.json)
          NEW_RULE='{"source": "'$RUNNER_IP'/32", "protocol": "6", "is-stateless": false, "source-type": "CIDR_BLOCK", "tcp-options": {"destination-port-range": {"max": 22, "min": 22}}}'
          NEW_RULES=$(echo "$RULES" | jq ". + [$NEW_RULE]")

          oci network security-list update --security-list-id "$SL_OCID" --ingress-security-rules "$NEW_RULES" --force --auth api_key
          echo "âœ… Porta 22 destrancada na Oracle! Aguardando 15s..."
          sleep 15

      - name: Executando Deploy AutomÃ¡tico via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.ORACLE_HOST }}
          username: ${{ secrets.ORACLE_USER }}
          key: ${{ secrets.ORACLE_SSH_KEY }}
          script: |
            echo "Iniciando Pipeline de Deploy Seguro..."

            # Se a VM Ubuntu estiver 100% crua, o Github Actions instala tudo sozinho agora:
            if ! command -v docker &> /dev/null; then
              echo "Instalando Docker e ferramentas bÃ¡sicas do zero..."
              sudo apt-get update
              sudo apt-get install -y git docker.io docker-compose-v2 socat
              sudo systemctl enable --now docker
              sudo usermod -aG docker ${{ secrets.ORACLE_USER }}
              
              # Tenta aplicar os grupos
              newgrp docker || true
            fi

            # Cloudflare WARP â€” necessÃ¡rio para que o Baileys (WhatsApp) funcione em IPs de data center
            if ! command -v warp-cli &> /dev/null; then
              echo "Instalando Cloudflare WARP..."
              curl -fsSL https://pkg.cloudflareclient.com/pubkey.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/cloudflare-warp-archive-keyring.gpg
              echo 'deb [arch=amd64 signed-by=/usr/share/keyrings/cloudflare-warp-archive-keyring.gpg] https://pkg.cloudflareclient.com/ jammy main' | sudo tee /etc/apt/sources.list.d/cloudflare-client.list
              sudo apt-get update -q && sudo apt-get install -y cloudflare-warp
              sudo systemctl enable warp-svc
              sudo systemctl start warp-svc
              sleep 3
              warp-cli --accept-tos registration new
              warp-cli --accept-tos mode proxy
              warp-cli --accept-tos connect

              # Relay socat: expÃµe o proxy SOCKS5 do WARP para a rede Docker (172.18.0.1:40000)
              sudo tee /etc/systemd/system/warp-socat-relay.service > /dev/null << 'SVCEOF'
[Unit]
Description=SOCKS5 relay WARP proxy para Docker network
After=warp-svc.service network.target
Wants=warp-svc.service

[Service]
Type=simple
ExecStart=/usr/bin/socat TCP-LISTEN:40000,fork,bind=172.18.0.1 TCP:127.0.0.1:40000
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
SVCEOF

              sudo tee /etc/systemd/system/warp-connect.service > /dev/null << 'SVCEOF'
[Unit]
Description=Conecta Cloudflare WARP no boot
After=warp-svc.service network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/bin/warp-cli --accept-tos connect
RemainAfterExit=yes
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
SVCEOF

              sudo systemctl daemon-reload
              sudo systemctl enable warp-socat-relay.service warp-connect.service
              sudo systemctl start warp-socat-relay.service
              echo "WARP instalado e relay socat ativo!"
            fi

            # Garante socat instalado mesmo que Docker jÃ¡ existia
            if ! command -v socat &> /dev/null; then
              sudo apt-get install -y socat
            fi

            # Garante que WARP e relay estÃ£o rodando (idempotente)
            sudo systemctl start warp-svc || true
            warp-cli --accept-tos connect || true
            sudo systemctl start warp-socat-relay.service || true

            if [ ! -d "/home/${{ secrets.ORACLE_USER }}/wesley-bot-whatsapp-assistant" ]; then
              git clone https://github.com/${{ github.repository }}.git /home/${{ secrets.ORACLE_USER }}/wesley-bot-whatsapp-assistant
            fi

            cd /home/${{ secrets.ORACLE_USER }}/wesley-bot-whatsapp-assistant

            git fetch --all
            git reset --hard origin/main
            git pull origin main

            # Recria as envs pra IA
            echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" > .env
            echo "EVOLUTION_API_KEY=${{ secrets.EVOLUTION_API_KEY }}" >> .env
            echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> .env

            # Recarrega MÃ¡quinas
            sudo docker compose down || docker compose down
            sudo docker compose up -d --build || docker compose up -d --build

            echo "Pipeline ConcluÃ­do com Sucesso! ðŸš€"

      - name: (Security) FECHAR Porta 22 SSH e apagar IP do GitHub
        if: always() # Garante que vai rodar MESMO se o deploy SSH explodir/falhar no meio do caminho
        run: |
          set -e
          RUNNER_IP=${{ steps.ip.outputs.ip }}
          SL_OCID="${{ secrets.OCI_SECURITY_LIST_OCID }}"

          if [ -z "$SL_OCID" ]; then exit 0; fi # Se falhou antes de ter o OCID, nem tenta rodar o fechamento

          echo "ðŸ”’ Removendo Rastro e trancando porta SSH..."
          oci network security-list get --security-list-id "$SL_OCID" --auth api_key --query 'data."ingress-security-rules"' --output json > clean_rules.json || exit 0

          RULES=$(cat clean_rules.json)
          CLEAN_RULES=$(echo "$RULES" | jq "map(select(.source != \"$RUNNER_IP/32\"))")

          oci network security-list update --security-list-id "$SL_OCID" --ingress-security-rules "$CLEAN_RULES" --force --auth api_key
          echo "âœ… Rastro de IP GitHub Apagado! Porta 22 bloqueada novamente."
