name: Deploy Oracle VPS Seguro
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Instalar OCI CLI (Oracle Cloud Infrastructure CLI)
        run: |
          python -m pip install --upgrade pip
          pip install oci-cli

      - name: Configurar Credenciais Oracle (OCI)
        run: |
          mkdir -p ~/.oci
          cat << 'EOF' > ~/.oci/config
          [DEFAULT]
          user=${{ secrets.OCI_USER_OCID }}
          fingerprint=${{ secrets.OCI_FINGERPRINT }}
          tenancy=${{ secrets.OCI_TENANCY_OCID }}
          region=${{ secrets.OCI_REGION }}
          key_file=/home/runner/.oci/oci_api_key.pem
          EOF

          # Modo seguro de injetar chaves multilinhas no Linux sem quebrar
          cat << 'EOF' > ~/.oci/oci_api_key.pem
          ${{ secrets.OCI_API_KEY }}
          EOF

          chmod 600 ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/config

      - name: Descobrir IP DinÃ¢mico do GitHub Actions
        id: ip
        run: |
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "ip=$RUNNER_IP" >> $GITHUB_OUTPUT
          echo "IP do Github Actions descoberto: $RUNNER_IP"

      - name: (Security) ABRIR Porta 22 SSH Apenas para o GitHub Actions
        run: |
          set -e
          RUNNER_IP=${{ steps.ip.outputs.ip }}
          SL_OCID="${{ secrets.OCI_SECURITY_LIST_OCID }}"

          if [ -z "$SL_OCID" ]; then
            echo "âŒ ERRO: A variÃ¡vel OCI_SECURITY_LIST_OCID nÃ£o foi encontrada no Github Secrets ou estÃ¡ vazia!"
            exit 2
          fi

          echo "ðŸ”„ Buscando regras do Firewall na Oracle..."
          # Testa autenticaÃ§Ã£o e salva em arquivo para debug
          if ! oci network security-list get --security-list-id "$SL_OCID" --auth api_key --query 'data."ingress-security-rules"' --output json > rules.json; then
             echo "âŒ ERRO: A Oracle rejeitou a conexÃ£o. OCI_API_KEY ou os IDs de Tenancy/User podem estar com espaÃ§os em branco!"
             exit 2
          fi

          echo "âœ… ConexÃ£o com a Oracle bem sucedida! Injetando IP $RUNNER_IP..."
          RULES=$(cat rules.json)
          NEW_RULE='{"source": "'$RUNNER_IP'/32", "protocol": "6", "is-stateless": false, "source-type": "CIDR_BLOCK", "tcp-options": {"destination-port-range": {"max": 22, "min": 22}}}'
          NEW_RULES=$(echo "$RULES" | jq ". + [$NEW_RULE]")

          oci network security-list update --security-list-id "$SL_OCID" --ingress-security-rules "$NEW_RULES" --force --auth api_key
          echo "âœ… Porta 22 destrancada na Oracle! Aguardando 15s..."
          sleep 15

      - name: Executando Deploy AutomÃ¡tico via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.ORACLE_HOST }}
          username: ${{ secrets.ORACLE_USER }}
          key: ${{ secrets.ORACLE_SSH_KEY }}
          script: |
            echo "Iniciando Pipeline de Deploy Seguro..."

            # Se a VM Ubuntu estiver 100% crua, o Github Actions instala tudo sozinho agora:
            if ! command -v docker &> /dev/null; then
              echo "Instalando Docker e ferramentas bÃ¡sicas do zero..."
              sudo apt-get update
              sudo apt-get install -y git docker.io docker-compose-v2 socat
              sudo systemctl enable --now docker
              sudo usermod -aG docker ${{ secrets.ORACLE_USER }}
              
              # Tenta aplicar os grupos
              newgrp docker || true
            fi

            # Cloudflare WARP â€” necessÃ¡rio para que o Baileys (WhatsApp) funcione em IPs de data center
            if ! command -v warp-cli &> /dev/null; then
              echo "Instalando Cloudflare WARP + redsocks..."
              curl -fsSL https://pkg.cloudflareclient.com/pubkey.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/cloudflare-warp-archive-keyring.gpg
              echo 'deb [arch=amd64 signed-by=/usr/share/keyrings/cloudflare-warp-archive-keyring.gpg] https://pkg.cloudflareclient.com/ jammy main' | sudo tee /etc/apt/sources.list.d/cloudflare-client.list
              sudo apt-get update -q && sudo apt-get install -y cloudflare-warp redsocks
              sudo systemctl enable warp-svc
              sudo systemctl start warp-svc
              sleep 3
              warp-cli --accept-tos registration new
              warp-cli --accept-tos mode proxy
              warp-cli --accept-tos connect

              # Relay socat: expÃµe o proxy SOCKS5 do WARP para a rede Docker (172.18.0.1:40000)
              printf '[Unit]\nDescription=SOCKS5 relay WARP proxy para Docker network\nAfter=warp-svc.service network.target\nWants=warp-svc.service\n\n[Service]\nType=simple\nExecStart=/usr/bin/socat TCP-LISTEN:40000,fork,bind=172.18.0.1 TCP:127.0.0.1:40000\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n' | sudo tee /etc/systemd/system/warp-socat-relay.service > /dev/null

              printf '[Unit]\nDescription=Conecta Cloudflare WARP no boot\nAfter=warp-svc.service network-online.target\nWants=network-online.target\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/warp-cli --accept-tos connect\nRemainAfterExit=yes\nRestart=on-failure\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\n' | sudo tee /etc/systemd/system/warp-connect.service > /dev/null

              # redsocks: proxy transparente SOCKS5 para containers Docker
              printf 'base {\n    log_debug = off;\n    log_info = on;\n    log = "stderr";\n    daemon = off;\n    redirector = iptables;\n}\nredsocks {\n    local_ip = 0.0.0.0;\n    local_port = 12345;\n    ip = 127.0.0.1;\n    port = 40000;\n    type = socks5;\n}\n' | sudo tee /etc/redsocks.conf > /dev/null

              printf '[Unit]\nDescription=RedSocks SOCKS5 Transparent Proxy (via WARP)\nAfter=network.target warp-svc.service\nWants=warp-svc.service\n\n[Service]\nType=simple\nExecStart=/usr/sbin/redsocks -c /etc/redsocks.conf\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n' | sudo tee /etc/systemd/system/redsocks.service > /dev/null

              # Script iptables para rotear todo TCP do Docker bot_network pelo redsocks -> WARP
              printf '#!/bin/bash\niptables -t nat -D PREROUTING -s 172.18.0.0/16 -p tcp -j DOCKER_WARP 2>/dev/null || true\niptables -t nat -F DOCKER_WARP 2>/dev/null || true\niptables -t nat -X DOCKER_WARP 2>/dev/null || true\niptables -t nat -N DOCKER_WARP\niptables -t nat -A DOCKER_WARP -d 0.0.0.0/8 -j RETURN\niptables -t nat -A DOCKER_WARP -d 10.0.0.0/8 -j RETURN\niptables -t nat -A DOCKER_WARP -d 100.64.0.0/10 -j RETURN\niptables -t nat -A DOCKER_WARP -d 127.0.0.0/8 -j RETURN\niptables -t nat -A DOCKER_WARP -d 169.254.0.0/16 -j RETURN\niptables -t nat -A DOCKER_WARP -d 172.16.0.0/12 -j RETURN\niptables -t nat -A DOCKER_WARP -d 192.168.0.0/16 -j RETURN\niptables -t nat -A DOCKER_WARP -d 224.0.0.0/4 -j RETURN\niptables -t nat -A DOCKER_WARP -d 240.0.0.0/4 -j RETURN\niptables -t nat -A DOCKER_WARP -p tcp -j REDIRECT --to-ports 12345\niptables -t nat -A PREROUTING -s 172.18.0.0/16 -p tcp -j DOCKER_WARP\necho "iptables WARP rules applied"\n' | sudo tee /usr/local/bin/setup-warp-iptables.sh > /dev/null
              sudo chmod +x /usr/local/bin/setup-warp-iptables.sh

              printf '[Unit]\nDescription=iptables rules for WARP transparent proxy\nAfter=network.target docker.service redsocks.service\nRequires=redsocks.service\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/setup-warp-iptables.sh\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n' | sudo tee /etc/systemd/system/warp-iptables.service > /dev/null

              sudo systemctl daemon-reload
              sudo systemctl enable warp-socat-relay.service warp-connect.service redsocks.service warp-iptables.service
              sudo systemctl start warp-socat-relay.service redsocks.service
              sudo /usr/local/bin/setup-warp-iptables.sh
              echo "WARP + redsocks + iptables instalados e ativos!"
            fi

            # Garante socat e redsocks instalados mesmo que Docker jÃ¡ existia
            if ! command -v socat &> /dev/null; then
              sudo apt-get install -y socat
            fi
            if ! command -v redsocks &> /dev/null; then
              sudo apt-get install -y redsocks
            fi

            # Garante que WARP e relay estÃ£o rodando (idempotente)
            sudo systemctl start warp-svc || true
            warp-cli --accept-tos connect || true
            sudo systemctl start warp-socat-relay.service || true

            if [ ! -d "/home/${{ secrets.ORACLE_USER }}/wesley-bot-whatsapp-assistant" ]; then
              git clone https://github.com/${{ github.repository }}.git /home/${{ secrets.ORACLE_USER }}/wesley-bot-whatsapp-assistant
            fi

            cd /home/${{ secrets.ORACLE_USER }}/wesley-bot-whatsapp-assistant

            git fetch --all
            git reset --hard origin/main
            git pull origin main

            # Recria as envs pra IA
            echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" > .env
            echo "EVOLUTION_API_KEY=${{ secrets.EVOLUTION_API_KEY }}" >> .env
            echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> .env
            echo "PANEL_SECRET_KEY=${{ secrets.PANEL_SECRET_KEY }}" >> .env
            echo "OWNER_JID=${{ secrets.OWNER_JID }}" >> .env
            echo "EVOLUTION_INSTANCE_TWO_NAME=${{ secrets.EVOLUTION_INSTANCE_TWO_NAME }}" >> .env
            echo "INSTANCE_TWO_OWNER_JID=${{ secrets.INSTANCE_TWO_OWNER_JID }}" >> .env

            # Apaga Ã­ndice FAISS antigo para forÃ§ar rebuild com todos os markdowns (projects/ incluÃ­do)
            rm -f vector_store.faiss vector_metadata.pkl

            # Recarrega MÃ¡quinas
            sudo docker compose down || docker compose down

            # -------------------------------------------------------------------
            # Limpeza Docker: garante que apenas a imagem atual existe na VPS.
            # Executado APÃ“S o compose down (nenhum container em uso) e ANTES
            # do build, para que o --build parta de uma base limpa.
            # -------------------------------------------------------------------

            # 1) Remove a imagem buildada do serviÃ§o 'api' (rebuilt a cada deploy)
            #    "docker compose images -q api" retorna o Image ID atual, se existir
            sudo docker compose images -q api 2>/dev/null \
              | xargs --no-run-if-empty sudo docker rmi --force 2>/dev/null || true

            # 2) Remove camadas Ã³rfÃ£s (dangling layers de builds anteriores sem tag)
            sudo docker image prune --force 2>/dev/null || true

            # 3) Limpa TODO o cache do BuildKit â€” maior ganho de espaÃ§o em disco
            #    O prÃ³ximo build baixa/reusa camadas via registry (layer cache do Docker Hub),
            #    mas nÃ£o gasta disco local com cache acumulado de deploys antigos.
            sudo docker builder prune --all --force 2>/dev/null || true

            echo "ðŸ§¹ Limpeza Docker concluÃ­da."

            # ForÃ§a pull da imagem evoapicloud (v2.3.7+) antes de subir
            sudo docker compose pull evolution-api || docker compose pull evolution-api || true
            sudo docker compose up -d --build || docker compose up -d --build

            # Falha o deploy se os containers nÃ£o subirem (evita "sucesso" falso)
            sleep 5
            RUNNING=$(sudo docker compose ps -a --status running -q 2>/dev/null | wc -l)
            if [ "$RUNNING" -lt 3 ]; then
              echo "ERRO: Containers nao estao rodando apos o deploy (running=$RUNNING)."
              sudo docker compose ps -a
              sudo docker compose logs --tail 80 api 2>/dev/null || true
              exit 1
            fi

            # Garante que WARP e redsocks estao rodando apos o deploy
            sudo systemctl start warp-svc || true
            warp-cli --accept-tos connect || true
            sudo systemctl start redsocks.service || true
            sudo systemctl start warp-socat-relay.service || true

            # Aplica regras iptables (recriam-se apos docker compose down/up que pode resetar chains)
            bash /usr/local/bin/setup-warp-iptables.sh || true

            echo "Pipeline ConcluÃ­do com Sucesso! ðŸš€"

      - name: (Security) FECHAR Porta 22 SSH e apagar IP do GitHub
        if: always() # Garante que vai rodar MESMO se o deploy SSH explodir/falhar no meio do caminho
        run: |
          set -e
          RUNNER_IP=${{ steps.ip.outputs.ip }}
          SL_OCID="${{ secrets.OCI_SECURITY_LIST_OCID }}"

          if [ -z "$SL_OCID" ]; then exit 0; fi # Se falhou antes de ter o OCID, nem tenta rodar o fechamento

          echo "ðŸ”’ Removendo Rastro e trancando porta SSH..."
          oci network security-list get --security-list-id "$SL_OCID" --auth api_key --query 'data."ingress-security-rules"' --output json > clean_rules.json || exit 0

          RULES=$(cat clean_rules.json)
          CLEAN_RULES=$(echo "$RULES" | jq "map(select(.source != \"$RUNNER_IP/32\"))")

          oci network security-list update --security-list-id "$SL_OCID" --ingress-security-rules "$CLEAN_RULES" --force --auth api_key
          echo "âœ… Rastro de IP GitHub Apagado! Porta 22 bloqueada novamente."
